# grept

`grept` stands for GoREPositorylinTer.

`grept` is a powerful, extensible linting tool for repositories. Inspired by [RepoLinter](https://github.com/todogroup/repolinter), `grept` is designed to ensure that your repositories follow certain predefined standards. It parses and evaluates configuration files, generates plans based on the specified configuration, and applies the plans. This makes it an excellent tool for maintaining consistency and quality in your codebase.

`grept` is written in Golang, using cobra for command-line interface and afero for file system abstraction. This makes it both highly extensible and testable.

## Installation

You can install `grept` directly using the `go install` command:

```
go install github.com/Azure/grept@latest
```

Please make sure you have Go installed and your `GOPATH` properly set up.

## How to use

`grept` supports two commands: `plan` and `apply`.

### Plan Command

The `plan` command generates a plan based on the specified configuration. 

```
grept plan [path-to-config-folder]
```

Replace `[path-to-config-folder]` with your configuration files folder's path. The `plan` command will parse all files with suffix `*.grept.hcl` and generate a plan. If all rule checks are successful, it will print \"All rule checks successful, nothing to do.\" Otherwise, it will print the plan.

Omitting `[path-to-config-folder]` will use the current folder instead.

### Apply Command

The `apply` command applies the plan generated by the `plan` command.

```shell
grept apply [path-to-config-folder]
```

Replace `[path-to-config-folder]` with your configuration files folder's path. The `apply` command will apply the fixes to the issues found by the `plan` command. If all fixes are applied successfully, it will print \"Plan applied successfully.\"

Omitting `[path-to-config-folder]` will use the current folder instead.

You can use the `-a` or `--auto` flag to apply fixes without confirmation.

The config folder path support multiple different types:

- [Local paths](https://developer.hashicorp.com/terraform/language/modules/sources#local-paths)
- [Terraform Registry](https://developer.hashicorp.com/terraform/language/modules/sources#terraform-registry)
- [GitHub](https://developer.hashicorp.com/terraform/language/modules/sources#github)
- [Bitbucket](https://developer.hashicorp.com/terraform/language/modules/sources#bitbucket)
- Generic [Git](https://developer.hashicorp.com/terraform/language/modules/sources#generic-git-repository), [Mercurial](https://developer.hashicorp.com/terraform/language/modules/sources#generic-mercurial-repository) repositories
- [HTTP URLs](https://developer.hashicorp.com/terraform/language/modules/sources#http-urls)
- [S3 buckets](https://developer.hashicorp.com/terraform/language/modules/sources#s3-bucket)
- [GCS buckets](https://developer.hashicorp.com/terraform/language/modules/sources#gcs-bucket)

An example:

```shell
grept apply git::https://github.com/lonegunmanb/grept-example-config.git//mit-example
```

You can check [Terraform Module sources](https://developer.hashicorp.com/terraform/language/modules/sources) document for more details.

```
grept apply -a [path-to-config-folder]
```

## Example

The following example config file would ensure that your repository contains a MIT license file:

```hcl
data http mit_license {
  url = "https://raw.githubusercontent.com/Azure/terraform-verified-module/main/LICENSE"
}

rule file_hash license {
  glob = "LICENSE"
  hash = sha1(data.http.mit_license.response_body)
}

fix local_file license {
  rule_id = rule.file_hash.license.id
  paths = [rule.file_hash.glob]
  content = data.http.mit_license.response_body
}
```

## Functions

All [built-in functions](https://developer.hashicorp.com/packer/docs/templates/hcl_templates/functions) provided by [HashiCorp Packer](https://www.packer.io/) are available.

## Blocks

You can find detailed explanations about different components of the `grept` tool.

The documents are organized by categories: `rule` blocks, `data` blocks, and `fix` blocks. 

### Rule Blocks

Rule blocks define the rules that should be enforced in the repository. 

- [`dir_exist`](./doc/r/dir_exist.md)
- [`file_hash`](./doc/r/file_hash.md)
- [`must_be_true`](./doc/r/must_be_true.md)

### Data Blocks

Data blocks define the data that should be collected from the repository.

- [`git_ignore`](./doc/d/git_ignore.md)
- [`http`](./doc/d/http.md)

### Fix Blocks

Fix blocks define the actions that should be taken when a rule fails.

- [`git_ignore`](./doc/f/git_ignore.md)
- [`local_file`](./doc/f/local_file.md)
- [`local_shell`](./doc/f/local_shell.md)
- [`rename_file`](./doc/f/rename_file.md)
- [`rm_local_file`](./doc/f/rm_local_file.md)
- [`yaml_transform`](./doc/f/yaml_transform.md)

For each block type, you can find detailed information about the block's attributes, exported attributes, and usage examples.

## Contributing

Contributions to `grept` are welcome! Please submit a pull request or issue on the [grept GitHub page](https://github.com/Azure/grept). 

## License

`grept` is released under the MIT license. For more information, see [LICENSE](https://github.com/Azure/grept/blob/main/LICENSE).

This tool used [HashiCorp Packer](https://www.packer.io/)'s built-in functions, but I've already locked Packer's version at v1.9.3 so it was a MPL license library.