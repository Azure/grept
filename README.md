# grept

`grept` stands for GoREPositorylinTer.

`grept` is a powerful, extensible linting tool for repositories. Inspired by [RepoLinter](https://github.com/todogroup/repolinter), `grept` is designed to ensure that your repositories follow certain predefined standards. It parses and evaluates configuration files, generates plans based on the specified configuration, and applies the plans. This makes it an excellent tool for maintaining consistency and quality in your codebase.

`grept` is written in Golang, using cobra for command-line interface and afero for file system abstraction. This makes it both highly extensible and testable.

## Installation

You can install `grept` directly using the `go install` command:

```
go install github.com/Azure/grept@latest
```

Please make sure you have Go installed and your `GOPATH` properly set up.

## How to use

`grept` supports two commands: `plan` and `apply`.

### Plan Command

The `plan` command generates a plan based on the specified configuration. 

```
grept plan [path-to-config-folder]
```

Replace `[path-to-config-folder]` with your configuration files folder's path. The `plan` command will parse all files with suffix `*.grept.hcl` and generate a plan. If all rule checks are successful, it will print \"All rule checks successful, nothing to do.\" Otherwise, it will print the plan.

Omitting `[path-to-config-folder]` will use the current folder instead.

### Apply Command

The `apply` command applies the plan generated by the `plan` command.

```shell
grept apply [path-to-config-folder]
```

Replace `[path-to-config-folder]` with your configuration files folder's path. The `apply` command will apply the fixes to the issues found by the `plan` command. If all fixes are applied successfully, it will print \"Plan applied successfully.\"

Omitting `[path-to-config-folder]` will use the current folder instead.

You can use the `-a` or `--auto` flag to apply fixes without confirmation.

```
grept apply -a [path-to-config-folder]
```

The config folder path support multiple different types:

- [Local paths](https://developer.hashicorp.com/terraform/language/modules/sources#local-paths)
- [Terraform Registry](https://developer.hashicorp.com/terraform/language/modules/sources#terraform-registry)
- [GitHub](https://developer.hashicorp.com/terraform/language/modules/sources#github)
- [Bitbucket](https://developer.hashicorp.com/terraform/language/modules/sources#bitbucket)
- Generic [Git](https://developer.hashicorp.com/terraform/language/modules/sources#generic-git-repository), [Mercurial](https://developer.hashicorp.com/terraform/language/modules/sources#generic-mercurial-repository) repositories
- [HTTP URLs](https://developer.hashicorp.com/terraform/language/modules/sources#http-urls)
- [S3 buckets](https://developer.hashicorp.com/terraform/language/modules/sources#s3-bucket)
- [GCS buckets](https://developer.hashicorp.com/terraform/language/modules/sources#gcs-bucket)

An example:

```shell
grept apply git::https://github.com/lonegunmanb/grept-example-config.git//mit-example
```

You can check [Terraform Module sources](https://developer.hashicorp.com/terraform/language/modules/sources) document for more details.

## Example

The following example config file would ensure that your repository contains a MIT license file:

```hcl
data http mit_license {
  url = "https://raw.githubusercontent.com/Azure/terraform-verified-module/main/LICENSE"
}

rule file_hash license {
  glob = "LICENSE"
  hash = sha1(data.http.mit_license.response_body)
}

fix local_file license {
  rule_ids = [rule.file_hash.license.id]
  paths    = [rule.file_hash.glob]
  content  = data.http.mit_license.response_body
}
```

## Functions

All [built-in functions](https://developer.hashicorp.com/packer/docs/templates/hcl_templates/functions) provided by [HashiCorp Packer](https://www.packer.io/) are available.

All [`toxxx` functions provided by Terraform `1.5.7`](https://github.com/hashicorp/terraform/blob/v1.5.7/internal/lang/functions.go#L133-L138) are supported:

* `tostring`
* `tonumber`
* `tobool`
* `toset`
* `tolist`
* `tomap`

We've provided the following new functions:

- `env`: To read environment variable, like `env("GITHUB_REPOSITORY")`.
- `compliment`: Return the compliment of multiple lists.
- `yaml2json`: Convert yaml to corresponding json string.

It seems like [`go-cty-yaml`](https://github.com/zclconf/go-cty-yaml) has a [bug](https://github.com/zclconf/go-cty-yaml/issues/11), so please do not use `yamldecode` function to parse and check Github action yaml files. I added this `yaml2json` function so you can convert yaml string to json first, then use `jsondecode` function to unmarshal it and check whether the github action file meets your requirement.

## Blocks

You can find detailed explanations about different components of the `grept` tool.

The documents are organized by categories: `rule` blocks, `data` blocks, and `fix` blocks. 

### Rule Blocks

Rule blocks define the rules that should be enforced in the repository. 

- [`dir_exist`](./doc/r/dir_exist.md)
- [`file_hash`](./doc/r/file_hash.md)
- [`must_be_true`](./doc/r/must_be_true.md)

### Data Blocks

Data blocks define the data that should be collected from the repository.

- [`git_ignore`](./doc/d/git_ignore.md)
- [`http`](./doc/d/http.md)

### Fix Blocks

Fix blocks define the actions that should be taken when a rule fails.

- [`copy_file`](./doc/f/copy_file.md)
- [`git_ignore`](./doc/f/git_ignore.md)
- [`local_file`](./doc/f/local_file.md)
- [`local_shell`](./doc/f/local_shell.md)
- [`rename_file`](./doc/f/rename_file.md)
- [`rm_local_file`](./doc/f/rm_local_file.md)
- [`yaml_transform`](./doc/f/yaml_transform.md)

For each block type, you can find detailed information about the block's attributes, exported attributes, and usage examples.

## Locals

You can define and use `locals` block in `grept` just like [Terraform](https://developer.hashicorp.com/terraform/language/values/locals).

## `for_each` support

You can use `for_each` like Terraform. `for_each` is a meta-argument, it can be used with:

* `data`
* `rule`
* `fix`

The `for_each` meta-argument accepts a map or a set of strings, and creates an instance for each item in that map or set. Each instance has a distinct block associated with it, and each is separately planed and applied.

```hcl
locals {
  items = toset(["item1", "item2", "item3"])
}

data "http" echo {
  for_each = local.items

  url          = "http://foo"
  request_body = jsonencode({
    query = each.value
  })
}

rule "must_be_true" sample {
  for_each = local.items

  condition = each.value != data.http.echo[each.value]response_body
}

fix "local_file" hello_world{
  for_each = local.items

  rule_ids = [rule.must_be_true.sample[each.value].id]
  paths    = [each.value]
  content  = each.value
}
```

## `precondition` support

The `precondition` block is used to specify a condition that must be met before a block is evaluated. This is useful for adding checks that prevent the rule from running when certain conditions are not met.

Here is an example of a `precondition` block that checks if the `GITHUB_TOKEN` environment variable exists:

```hcl
rule "must_be_true" "check_env" {
  precondition {
    condition     = env("GITHUB_TOKEN") != ""
    error_message = "GITHUB_TOKEN environment variable must be set"
  }
  condition = true
}

## Contributing

Contributions to `grept` are welcome! Please submit a pull request or issue on the [grept GitHub page](https://github.com/Azure/grept). 

## License

`grept` is released under the MIT license. For more information, see [LICENSE](https://github.com/Azure/grept/blob/main/LICENSE).